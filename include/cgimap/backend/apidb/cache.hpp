/*
 * Copyright (c) 2009
 * Matt Amos, John Maddock
 *
 * Based on boost/regex/pending/object_cache.hpp

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */

#ifndef CACHE_HPP
#define CACHE_HPP

#include <map>
#include <list>
#include <stdexcept>
#include <string>
#include <boost/config.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/function.hpp>

template <class Key, class Object> class cache {
public:
  typedef std::pair< ::boost::shared_ptr<Object const>, Key const *> value_type;
  typedef std::list<value_type> list_type;
  typedef typename list_type::iterator list_iterator;
  typedef std::map<Key, list_iterator> map_type;
  typedef typename map_type::iterator map_iterator;
  typedef typename list_type::size_type size_type;
  typedef boost::function<Object *(Key)> function_type;

  cache(function_type f, size_type m);

  boost::shared_ptr<Object const> get(const Key &k);

private:
  struct data {
    list_type cont;
    map_type index;
  };

  // functor to get a value which isn't in the cache.
  function_type fetch;

  // maximum size of the cache, set at construction time
  const size_type max_cache_size;

  // Needed by compilers not implementing the resolution to DR45. For reference,
  // see http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#45.
  friend struct data;
};

template <class Key, class Object>
cache<Key, Object>::cache(function_type f, size_type m)
    : fetch(f), max_cache_size(m) {}

template <class Key, class Object>
boost::shared_ptr<Object const> cache<Key, Object>::get(const Key &k) {
  typedef typename cache<Key, Object>::data object_data;
  typedef typename map_type::size_type map_size_type;
  static object_data s_data;

  //
  // see if the object is already in the cache:
  //
  map_iterator mpos = s_data.index.find(k);
  if (mpos != s_data.index.end()) {
    //
    // Eureka!
    // We have a cached item, bump it up the list and return it:
    //
    if (--(s_data.cont.end()) != mpos->second) {
      // splice out the item we want to move:
      list_type temp;
      temp.splice(temp.end(), s_data.cont, mpos->second);
      // and now place it at the end of the list:
      s_data.cont.splice(s_data.cont.end(), temp, temp.begin());
      BOOST_ASSERT(*(s_data.cont.back().second) == k);
      // update index with new position:
      mpos->second = --(s_data.cont.end());
      BOOST_ASSERT(&(mpos->first) == mpos->second->second);
      BOOST_ASSERT(&(mpos->first) == s_data.cont.back().second);
    }
    return s_data.cont.back().first;
  }
  //
  // if we get here then the item is not in the cache,
  // so create it:
  //
  boost::shared_ptr<Object const> result(fetch(k));
  //
  // Add it to the list, and index it:
  //
  s_data.cont.push_back(value_type(result, 0));
  s_data.index.insert(std::make_pair(k, --(s_data.cont.end())));
  s_data.cont.back().second = &(s_data.index.find(k)->first);
  map_size_type s = s_data.index.size();
  BOOST_ASSERT(s_data.index[k]->first.get() == result.get());
  BOOST_ASSERT(&(s_data.index.find(k)->first) == s_data.cont.back().second);
  BOOST_ASSERT(s_data.index.find(k)->first == k);
  if (s > max_cache_size) {
    //
    // We have too many items in the list, so we need to start
    // popping them off the back of the list, but only if they're
    // being held uniquely by us:
    //
    list_iterator pos = s_data.cont.begin();
    list_iterator last = s_data.cont.end();
    while ((pos != last) && (s > max_cache_size)) {
      if (pos->first.unique()) {
        list_iterator condemmed(pos);
        ++pos;
        // now remove the items from our containers,
        // then order has to be as follows:
        BOOST_ASSERT(s_data.index.find(*(condemmed->second)) !=
                     s_data.index.end());
        s_data.index.erase(*(condemmed->second));
        s_data.cont.erase(condemmed);
        --s;
      } else
        --pos;
    }
    BOOST_ASSERT(s_data.index[k]->first.get() == result.get());
    BOOST_ASSERT(&(s_data.index.find(k)->first) == s_data.cont.back().second);
    BOOST_ASSERT(s_data.index.find(k)->first == k);
  }
  return result;
}

#endif /* CACHE_HPP */
