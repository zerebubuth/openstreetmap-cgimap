/*
 * Copyright (c) 2009
 * Matt Amos, John Maddock
 *
 * Based on boost/regex/pending/object_cache.hpp

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */

#ifndef CACHE_HPP
#define CACHE_HPP

#include <cassert>
#include <functional>
#include <map>
#include <memory>
#include <list>
#include <set>
#include <stdexcept>
#include <string>
#include <boost/config.hpp>

template <class Key, class Object> class cache {
public:
  using value_type = std::pair< ::std::shared_ptr<Object const>, Key const *>;
  using list_type = std::list<value_type>;
  using list_iterator = typename list_type::iterator;
  using map_type = std::map<Key, list_iterator>;
  using map_iterator = typename map_type::iterator;
  using size_type = typename list_type::size_type;
  using function_type_fetch = std::function< std::map< Key, Object* >(std::set<Key>) >;

  cache(function_type_fetch f, size_type m);

  std::shared_ptr<Object const> get(const Key &k);
  void prefetch(const std::set<Key> & k);

private:

  struct data {
    list_type cont;
    map_type index;
  };

  using object_data = typename cache<Key, Object>::data;

  // functor to retrieve changesets not available in the cache
  function_type_fetch f_fetch;

  // maximum size of the cache, set at construction time
  const size_type max_cache_size;

  // Needed by compilers not implementing the resolution to DR45. For reference,
  // see http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#45.
  friend struct data;

  inline object_data * sdata();
  void insert_into_cache(const Key &k, std::shared_ptr<Object const> result);
  bool is_in_cache(const Key &k);
};

template <class Key, class Object>
cache<Key, Object>::cache(function_type_fetch f, size_type m)
    : f_fetch(f), max_cache_size(m) {}

template <class Key, class Object>
void cache<Key, Object>::prefetch(const std::set<Key> & keys) {

  std::set<Key> new_keys;

  for (const auto& k : keys) {
    if (!is_in_cache(k))
      new_keys.insert(k);
  }

  std::map<Key, Object* > result(f_fetch(new_keys));

  for (const auto& r : result) {
    std::shared_ptr<Object const> result(r.second);
    insert_into_cache(r.first, result);
  }

}

template <class Key, class Object>
typename cache<Key, Object>::data * cache<Key, Object>::sdata() {

  static object_data s_data;

  return &s_data;
}

template <class Key, class Object>
bool cache<Key, Object>::is_in_cache(const Key &k) {

  return (sdata()->index.find(k) != sdata()->index.end());
}

template <class Key, class Object>
std::shared_ptr<Object const> cache<Key, Object>::get(const Key &k) {

  //
  // see if the object is already in the cache:
  //
  map_iterator mpos = sdata()->index.find(k);
  if (mpos != sdata()->index.end()) {
    //
    // Eureka!
    // We have a cached item, bump it up the list and return it:
    //
    if (--(sdata()->cont.end()) != mpos->second) {
      // splice out the item we want to move:
      list_type temp;
      temp.splice(temp.end(), sdata()->cont, mpos->second);
      // and now place it at the end of the list:
      sdata()->cont.splice(sdata()->cont.end(), temp, temp.begin());
      assert(*(sdata()->cont.back().second) == k);
      // update index with new position:
      mpos->second = --(sdata()->cont.end());
      assert(&(mpos->first) == mpos->second->second);
      assert(&(mpos->first) == sdata()->cont.back().second);
    }
    return sdata()->cont.back().first;
  }
  //
  // if we get here then the item is not in the cache,
  // so create it:
  //
  std::map<Key, Object* > res(f_fetch({k}));
  std::shared_ptr<Object const> result(res[k]);
  insert_into_cache(k, result);
  return result;
}

template <class Key, class Object>
void cache<Key, Object>::insert_into_cache(const Key &k, std::shared_ptr<Object const> result) {

  using map_size_type = typename map_type::size_type;

  // don't insert element if already in cache
  if (sdata()->index.find(k) != sdata()->index.end())
    return;

  //
  // Add it to the list, and index it:
  //
  sdata()->cont.push_back(value_type(result, 0));
  sdata()->index.insert(std::make_pair(k, --(sdata()->cont.end())));
  sdata()->cont.back().second = &(sdata()->index.find(k)->first);
  map_size_type s = sdata()->index.size();
  assert(sdata()->index[k]->first.get() == result.get());
  assert(&(sdata()->index.find(k)->first) == sdata()->cont.back().second);
  assert(sdata()->index.find(k)->first == k);
  if (s > max_cache_size) {
    //
    // We have too many items in the list, so we need to start
    // popping them off the back of the list, but only if they're
    // being held uniquely by us:
    //
    list_iterator pos = sdata()->cont.begin();
    list_iterator last = sdata()->cont.end();
    while ((pos != last) && (s > max_cache_size)) {
      if (pos->first.unique()) {
        list_iterator condemmed(pos);
        ++pos;
        // now remove the items from our containers,
        // then order has to be as follows:
        assert(sdata()->index.find(*(condemmed->second)) !=
            sdata()->index.end());
        sdata()->index.erase(*(condemmed->second));
        sdata()->cont.erase(condemmed);
        --s;
      } else
        --pos;
    }
    assert(sdata()->index[k]->first.get() == result.get());
    assert(&(sdata()->index.find(k)->first) == sdata()->cont.back().second);
    assert(sdata()->index.find(k)->first == k);
  }

}

#endif /* CACHE_HPP */
